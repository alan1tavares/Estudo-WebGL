<!DOCTYPE html>
<html>
<head>
	<title></title>
	<script type="text/javascript" src="../three.js-master/build/three.js"></script>
	<script type="text/javascript" src="../three.js-master/examples/js/controls/OrbitControls.js"></script>
	<script type="text/javascript" src="../three.js-master/examples/js/controls/TransformControls.js"></script>
	<script type="text/javascript" src="build/physi.js"></script>
</head>
<body>
	<div id="webgl"></div>
	<script type="text/javascript">

		'use strict';

		// Configure physi
    	Physijs.scripts.worker = 'build/physijs_worker.js';
    	Physijs.scripts.ammo = '../build/ammo.js';

		var scene, camera, renderer, controlsObject, controlsCamera, raycaster;

		var mouse = new THREE.Vector2();
		var intersectObjects = [];

		var transformObject = false;

		//Objects
		var plane;
		var cube;

		function init(){
			// Creating scene
			scene = new Physijs.Scene();
			
			// Create camera
			camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
			camera.position.set(15,15,30);
			camera.lookAt(scene.position);

			// Create render
			renderer = new THREE.WebGLRenderer();
			renderer.setClearColor(0xEEEEEE);
			renderer.setSize(window.innerWidth, window.innerHeight);

			// Set output webGl
			document.getElementById("webgl").appendChild(renderer.domElement);

			// Controls
			
			// Camera
			controlsCamera = new THREE.OrbitControls(camera, renderer.domElement);
			controlsCamera.addEventListener('change', render);

			// Object
			controlsObject = new THREE.TransformControls(camera, renderer.domElement);
			controlsObject.setMode("translate");
			controlsObject.addEventListener('change', render);
			
			scene.add(controlsObject);

			// Raycaster
			raycaster = new THREE.Raycaster();
			
			// Create objects
			objects();

			// Register events
			window.addEventListener('mousedown', onMouseDown);
			window.addEventListener('onmouseup', onMouseUp, false); 
		}

		function animate(){
			//--Teste--//
			cube.position.set(10,3,5);
			cube.__dirtyPosition = true;

			cube.setLinearVelocity(new THREE.Vector3(0,0,0));
			cube.setAngularVelocity(new THREE.Vector3(0,0,0));

			// run physics
			scene.simulate();
			// render the scene
			render();

			controlsCamera.update();
			controlsObject.update();

			requestAnimationFrame(animate);
		}

		function render(){
			// Rendering the scene
			renderer.render(scene, camera);
		}

		// Create objects
		function objects(){
			// Axes
			var axes = new THREE.AxisHelper(20);
			scene.add(axes);

			// Cubes
			var geometry = new THREE.BoxGeometry(1,1,1);
			var material = new THREE.MeshBasicMaterial({
				color: 0xff0000
			});
			cube = new Physijs.BoxMesh(geometry, material);
			cube.position.set(10,3,5);

			scene.add(cube);
			intersectObjects.push(cube);

			//Ground
			var planeGeometry = new THREE.PlaneGeometry(10, 10);
			var planeMaterial = new THREE.MeshBasicMaterial({
				color: 0x00ff00
			});
			plane = new Physijs.PlaneMesh(planeGeometry, planeMaterial);
			plane.rotateX(-Math.PI/2);
			scene.add(plane);
			intersectObjects.push(plane);

		}

		// Mouse events
		function onMouseDown(e){
			if(e.button === 0){
				e.preventDefault();

				mouse.x =   (e.clientX / window.innerWidth)  * 2 - 1;
				mouse.y = - (e.clientY / window.innerHeight) * 2 + 1;

				//camera.updateMatrixWorld();

				raycaster.setFromCamera(mouse, camera);

				var intersects = raycaster.intersectObjects(intersectObjects);

				if(intersects.length > 0){
					controlsObject.attach(intersects[0].object);
					controlsObject.visible = true;
					intersects[0].object.material.color.set(Math.random() * 0xffffff);
				}else{
					controlsObject.detach();
				}
			}
		}

		function onMouseUp(event){

		}

		init();
		animate();



	</script>
</body>
</html>